{"ast":null,"code":"import React, { useRef, useEffect, useState } from 'react';\n\nvar getRandomNumberBetween = function getRandomNumberBetween(min, max) {\n  return Math.floor(Math.random() * max) + min;\n};\n\nvar createSlices = function createSlices(height) {\n  var heightOffsets = [];\n\n  for (var i = 0; i < height;) {\n    var randomHeight = getRandomNumberBetween(3, 20);\n    var newHeightOffset = {\n      height: randomHeight,\n      offset: i\n    };\n    heightOffsets.push(newHeightOffset);\n    i += randomHeight;\n  }\n\n  var trimmedHeightOffsets = heightOffsets.slice(0, -1);\n\n  var _trimmedHeightOffsets = trimmedHeightOffsets.slice(-1),\n      lastSet = _trimmedHeightOffsets[0];\n\n  var lastHeightOffset = {\n    height: height - ((lastSet == null ? void 0 : lastSet.offset) + (lastSet == null ? void 0 : lastSet.height)),\n    offset: (lastSet == null ? void 0 : lastSet.offset) + (lastSet == null ? void 0 : lastSet.height)\n  };\n  if (!lastSet) return [];\n  return [].concat(trimmedHeightOffsets, [lastHeightOffset]);\n};\n\nvar getRatio = function getRatio(imageDims) {\n  return imageDims.width / imageDims.height;\n};\n\nvar getRatioImageSize = function getRatioImageSize(containerDims, imageDims) {\n  var imageRatio = getRatio(imageDims);\n  return {\n    height: containerDims.height,\n    width: containerDims.height * imageRatio\n  };\n};\n\nvar useObserver = function useObserver(callback, element) {\n  var observer = useRef(null);\n  useEffect(function () {\n    if (!element.current) return;\n    var current = element.current;\n\n    var observe = function observe() {\n      if (current && observer.current) {\n        observer.current.observe(current);\n      }\n    }; // if we are already observing old element\n\n\n    if (observer && observer.current && current) {\n      observer.current.unobserve(current);\n    }\n\n    observer.current = new ResizeObserver(callback);\n    observe();\n    return function () {\n      if (observer && observer.current && current) {\n        observer.current.unobserve(current);\n      }\n    };\n  }, [element, callback]);\n};\n\nvar Slice = function Slice(_ref) {\n  var isGlitching = _ref.isGlitching,\n      top = _ref.top,\n      imageHeight = _ref.imageHeight,\n      image = _ref.image;\n\n  var _useState = useState(0),\n      translateX = _useState[0],\n      setTranslateX = _useState[1];\n\n  var _useState2 = useState(0),\n      hue = _useState2[0],\n      setHue = _useState2[1];\n\n  var _useState3 = useState(false),\n      negativeTranslate = _useState3[0],\n      setNegativeTranslate = _useState3[1];\n\n  var glitch = function glitch() {\n    setNegativeTranslate(getRandomNumberBetween(0, 2) !== 0);\n    setTranslateX(getRandomNumberBetween(1, 25));\n    setHue(getRandomNumberBetween(0, 360));\n  };\n\n  var returnToNormal = function returnToNormal() {\n    setTranslateX(0);\n    setHue(0);\n  };\n\n  useEffect(function () {\n    var randomInterval = getRandomNumberBetween(1, 1000);\n    var interval = setInterval(function () {\n      isGlitching ? glitch() : returnToNormal();\n    }, randomInterval);\n    return function () {\n      return clearInterval(interval);\n    };\n  });\n  return React.createElement(\"div\", {\n    className: \"Slice\",\n    style: {\n      backgroundImage: \"url(\" + image + \")\",\n      backgroundSize: 'contain',\n      backgroundRepeat: 'no-repeat',\n      backgroundPosition: 'center',\n      height: imageHeight,\n      transform: \"translateY(-\" + top + \"px) translateX(\" + (negativeTranslate ? '-' : '') + translateX + \"px)\",\n      filter: \"hue-rotate(\" + hue + \"deg)\"\n    }\n  });\n};\n\nvar GlitchedImage = function GlitchedImage(_ref) {\n  var image = _ref.image;\n  var slicesRef = useRef(null);\n\n  var _useState = useState({\n    width: 0,\n    height: 0\n  }),\n      containerDims = _useState[0],\n      setContainerDims = _useState[1];\n\n  var _useState2 = useState({\n    width: 0,\n    height: 0\n  }),\n      imageDims = _useState2[0],\n      setImageDims = _useState2[1];\n\n  var _useState3 = useState([]),\n      heightOffsets = _useState3[0],\n      setHeightOffsets = _useState3[1];\n\n  var _useState4 = useState(false),\n      isGlitching = _useState4[0],\n      setIsGlitching = _useState4[1];\n\n  var runInObserver = function runInObserver() {\n    var _slicesRef$current, _slicesRef$current2;\n\n    setContainerDims({\n      width: ((_slicesRef$current = slicesRef.current) == null ? void 0 : _slicesRef$current.clientWidth) || 0,\n      height: ((_slicesRef$current2 = slicesRef.current) == null ? void 0 : _slicesRef$current2.clientHeight) || 0\n    });\n  };\n\n  useObserver(runInObserver, slicesRef); // get image width and height\n\n  useEffect(function () {\n    var myImage = new Image();\n\n    myImage.onload = function () {\n      setImageDims(getRatioImageSize(containerDims, {\n        height: myImage.height,\n        width: myImage.width\n      }));\n    };\n\n    myImage.src = image;\n  }, [image, containerDims]); // trigger glitching with random intervals\n\n  useEffect(function () {\n    var lowRandom = getRandomNumberBetween(100, 600);\n    var highRandom = getRandomNumberBetween(1000, 3000);\n    var timer = isGlitching ? lowRandom : highRandom;\n    var interval = setInterval(function () {\n      setIsGlitching(function (prevGlitching) {\n        return !prevGlitching;\n      });\n    }, timer);\n    return function () {\n      return clearInterval(interval);\n    };\n  }, [isGlitching]); // create heightOffsets array with container height\n\n  useEffect(function () {\n    setHeightOffsets(createSlices(containerDims.height));\n  }, [containerDims.height, containerDims.width]);\n  return React.createElement(\"div\", {\n    style: {\n      height: '100%',\n      width: '100%'\n    },\n    ref: slicesRef\n  }, heightOffsets.map(function (heightOffset, i) {\n    return React.createElement(\"div\", {\n      key: i,\n      style: {\n        position: 'relative',\n        height: heightOffset.height,\n        overflow: 'hidden'\n      }\n    }, React.createElement(Slice, {\n      isGlitching: isGlitching,\n      top: heightOffset.offset,\n      imageHeight: imageDims.height,\n      image: image\n    }));\n  }));\n};\n\nexport { GlitchedImage };","map":{"version":3,"sources":["../src/helpers.ts","../src/hooks.ts","../src/components/Slice.tsx","../src/components/GlitchedImage.tsx"],"names":["getRandomNumberBetween","Math","createSlices","heightOffsets","i","randomHeight","newHeightOffset","height","offset","trimmedHeightOffsets","lastSet","lastHeightOffset","getRatio","imageDims","getRatioImageSize","imageRatio","containerDims","width","useObserver","observer","useRef","useEffect","element","current","observe","Slice","isGlitching","top","imageHeight","image","translateX","setTranslateX","useState","hue","setHue","negativeTranslate","setNegativeTranslate","glitch","returnToNormal","randomInterval","interval","setInterval","clearInterval","className","style","backgroundImage","backgroundSize","backgroundRepeat","backgroundPosition","transform","filter","GlitchedImage","slicesRef","setContainerDims","setImageDims","setHeightOffsets","setIsGlitching","runInObserver","myImage","lowRandom","highRandom","timer","ref","key","position","heightOffset","overflow"],"mappings":"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","sourcesContent":["import { DimensionsType, heightOffsetType } from \"./Typings\"\n\nexport const getRandomNumberBetween = (min: number, max: number) => {\n  return Math.floor(Math.random() * max) + min\n}\n\nexport const createSlices = (height: number) => {\n  let heightOffsets: heightOffsetType[] = []\n  for (let i = 0; i < height;) {\n    const randomHeight = getRandomNumberBetween(3, 20)\n    const newHeightOffset = { height: randomHeight, offset: i }\n    heightOffsets.push(newHeightOffset)\n    i += randomHeight\n  }\n  const trimmedHeightOffsets = heightOffsets.slice(0, -1)\n  const [lastSet] = trimmedHeightOffsets.slice(-1)\n  const lastHeightOffset = {\n    height: height - (lastSet?.offset + lastSet?.height),\n    offset: lastSet?.offset + lastSet?.height,\n  }\n  if (!lastSet) return []\n  return [...trimmedHeightOffsets, lastHeightOffset]\n}\n\nexport const getRatio = (imageDims: DimensionsType) => {\n  return imageDims.width / imageDims.height\n}\n\nexport const getRatioImageSize = (\n  containerDims: DimensionsType,\n  imageDims: DimensionsType,\n) => {\n  const imageRatio = getRatio(imageDims)\n  return {\n    height: containerDims.height,\n    width: containerDims.height * imageRatio,\n  }\n}\n","import { RefObject, useEffect, useRef } from 'react'\n\nexport const useObserver = (callback: () => void, element: RefObject<HTMLDivElement>) => {\n  const observer = useRef<any>(null)\n\n  useEffect(() => {\n    if (!element.current) return\n    const { current } = element\n    const observe = () => {\n      if (current && observer.current) {\n        observer.current.observe(current)\n      }\n    }\n    // if we are already observing old element\n    if (observer && observer.current && current) {\n      observer.current.unobserve(current)\n    }\n    observer.current = new ResizeObserver(callback);\n    observe()\n\n    return () => {\n      if (observer && observer.current && current) {\n        observer.current.unobserve(current)\n      }\n    }\n  }, [element, callback])\n}\n","import React, { useState, useEffect } from 'react'\nimport { getRandomNumberBetween } from '../helpers'\n\nexport const Slice: React.FC<{\n  isGlitching: boolean,\n  top: number,\n  imageHeight: number,\n  image: string,\n}> = ({ isGlitching, top, imageHeight, image }) => {\n  const [translateX, setTranslateX] = useState(0)\n  const [hue, setHue] = useState(0)\n  const [negativeTranslate, setNegativeTranslate] = useState(false)\n\n  const glitch = () => {\n    setNegativeTranslate(getRandomNumberBetween(0, 2) !== 0)\n    setTranslateX(getRandomNumberBetween(1, 25))\n    setHue((getRandomNumberBetween(0, 360)))\n  }\n\n  const returnToNormal = () => {\n    setTranslateX(0)\n    setHue(0)\n  }\n\n  useEffect(() => {\n    const randomInterval = getRandomNumberBetween(1, 1000)\n    const interval = setInterval(() => {\n      isGlitching ? glitch() : returnToNormal()\n    }, randomInterval)\n    return () => clearInterval(interval)\n  })\n\n  return (\n    <div\n      className=\"Slice\"\n      style={{\n        backgroundImage: `url(${image})`,\n        backgroundSize: 'contain',\n        backgroundRepeat: 'no-repeat',\n        backgroundPosition: 'center',\n        height: imageHeight,\n        transform: `translateY(-${top}px) translateX(${negativeTranslate ? '-' : ''}${translateX}px)`,\n        filter: `hue-rotate(${hue}deg)`,\n      }}\n    />\n  )\n}\n","import React, { useState, useEffect, useRef } from 'react'\nimport { createSlices, getRandomNumberBetween, getRatioImageSize } from '../helpers'\nimport { useObserver } from '../hooks'\nimport { heightOffsetType } from '../Typings'\nimport { Slice } from './Slice'\n\nexport const GlitchedImage: React.FC<{ image: string}> = ({ image }) => {\n  const slicesRef = useRef<HTMLDivElement>(null)\n  const [containerDims, setContainerDims] = useState({ width: 0, height: 0 })\n  const [imageDims, setImageDims] = useState({ width: 0, height: 0 })\n  const [heightOffsets, setHeightOffsets] = useState<heightOffsetType[]>([])\n  const [isGlitching, setIsGlitching] = useState(false)\n  const runInObserver = () => {\n    setContainerDims({\n      width: slicesRef.current?.clientWidth || 0,\n      height: slicesRef.current?.clientHeight || 0,\n    })\n  }\n  useObserver(runInObserver, slicesRef)\n\n\n  // get image width and height\n  useEffect(() => {\n    const myImage = new Image()\n    myImage.onload = () => {\n      setImageDims(\n        getRatioImageSize(\n          containerDims,\n          { height: myImage.height, width: myImage.width },\n        ),\n      )\n    }\n    myImage.src = image\n\n  }, [image, containerDims])\n\n  // trigger glitching with random intervals\n  useEffect(() => {\n    const lowRandom = getRandomNumberBetween(100, 600)\n    const highRandom = getRandomNumberBetween(1000, 3000)\n    const timer = isGlitching ? lowRandom : highRandom\n    const interval = setInterval(() => {\n      setIsGlitching((prevGlitching) => !prevGlitching)\n    }, timer)\n    return () => clearInterval(interval)\n  }, [isGlitching])\n\n  // create heightOffsets array with container height\n  useEffect(() => {\n    setHeightOffsets(createSlices(containerDims.height))\n  }, [containerDims.height, containerDims.width])\n  return (\n    <div style={{ height: '100%', width: '100%' }} ref={slicesRef}>\n      {heightOffsets.map((heightOffset, i) => (\n        <div\n          key={i}\n          style={{\n            position: 'relative',\n            height: heightOffset.height,\n            overflow: 'hidden',\n          }}\n        >\n          <Slice\n            isGlitching={isGlitching}\n            top={heightOffset.offset}\n            imageHeight={imageDims.height}\n            image={image}\n          />\n        </div>\n      ))}\n    </div>\n  )\n}\n"]},"metadata":{},"sourceType":"module"}