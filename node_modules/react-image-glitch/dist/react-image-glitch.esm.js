import React, { useRef, useEffect, useState } from 'react';

var getRandomNumberBetween = function getRandomNumberBetween(min, max) {
  return Math.floor(Math.random() * max) + min;
};
var createSlices = function createSlices(height) {
  var heightOffsets = [];

  for (var i = 0; i < height;) {
    var randomHeight = getRandomNumberBetween(3, 20);
    var newHeightOffset = {
      height: randomHeight,
      offset: i
    };
    heightOffsets.push(newHeightOffset);
    i += randomHeight;
  }

  var trimmedHeightOffsets = heightOffsets.slice(0, -1);

  var _trimmedHeightOffsets = trimmedHeightOffsets.slice(-1),
      lastSet = _trimmedHeightOffsets[0];

  var lastHeightOffset = {
    height: height - ((lastSet == null ? void 0 : lastSet.offset) + (lastSet == null ? void 0 : lastSet.height)),
    offset: (lastSet == null ? void 0 : lastSet.offset) + (lastSet == null ? void 0 : lastSet.height)
  };
  if (!lastSet) return [];
  return [].concat(trimmedHeightOffsets, [lastHeightOffset]);
};
var getRatio = function getRatio(imageDims) {
  return imageDims.width / imageDims.height;
};
var getRatioImageSize = function getRatioImageSize(containerDims, imageDims) {
  var imageRatio = getRatio(imageDims);
  return {
    height: containerDims.height,
    width: containerDims.height * imageRatio
  };
};

var useObserver = function useObserver(callback, element) {
  var observer = useRef(null);
  useEffect(function () {
    if (!element.current) return;
    var current = element.current;

    var observe = function observe() {
      if (current && observer.current) {
        observer.current.observe(current);
      }
    }; // if we are already observing old element


    if (observer && observer.current && current) {
      observer.current.unobserve(current);
    }

    observer.current = new ResizeObserver(callback);
    observe();
    return function () {
      if (observer && observer.current && current) {
        observer.current.unobserve(current);
      }
    };
  }, [element, callback]);
};

var Slice = function Slice(_ref) {
  var isGlitching = _ref.isGlitching,
      top = _ref.top,
      imageHeight = _ref.imageHeight,
      image = _ref.image;

  var _useState = useState(0),
      translateX = _useState[0],
      setTranslateX = _useState[1];

  var _useState2 = useState(0),
      hue = _useState2[0],
      setHue = _useState2[1];

  var _useState3 = useState(false),
      negativeTranslate = _useState3[0],
      setNegativeTranslate = _useState3[1];

  var glitch = function glitch() {
    setNegativeTranslate(getRandomNumberBetween(0, 2) !== 0);
    setTranslateX(getRandomNumberBetween(1, 25));
    setHue(getRandomNumberBetween(0, 360));
  };

  var returnToNormal = function returnToNormal() {
    setTranslateX(0);
    setHue(0);
  };

  useEffect(function () {
    var randomInterval = getRandomNumberBetween(1, 1000);
    var interval = setInterval(function () {
      isGlitching ? glitch() : returnToNormal();
    }, randomInterval);
    return function () {
      return clearInterval(interval);
    };
  });
  return React.createElement("div", {
    className: "Slice",
    style: {
      backgroundImage: "url(" + image + ")",
      backgroundSize: 'contain',
      backgroundRepeat: 'no-repeat',
      backgroundPosition: 'center',
      height: imageHeight,
      transform: "translateY(-" + top + "px) translateX(" + (negativeTranslate ? '-' : '') + translateX + "px)",
      filter: "hue-rotate(" + hue + "deg)"
    }
  });
};

var GlitchedImage = function GlitchedImage(_ref) {
  var image = _ref.image;
  var slicesRef = useRef(null);

  var _useState = useState({
    width: 0,
    height: 0
  }),
      containerDims = _useState[0],
      setContainerDims = _useState[1];

  var _useState2 = useState({
    width: 0,
    height: 0
  }),
      imageDims = _useState2[0],
      setImageDims = _useState2[1];

  var _useState3 = useState([]),
      heightOffsets = _useState3[0],
      setHeightOffsets = _useState3[1];

  var _useState4 = useState(false),
      isGlitching = _useState4[0],
      setIsGlitching = _useState4[1];

  var runInObserver = function runInObserver() {
    var _slicesRef$current, _slicesRef$current2;

    setContainerDims({
      width: ((_slicesRef$current = slicesRef.current) == null ? void 0 : _slicesRef$current.clientWidth) || 0,
      height: ((_slicesRef$current2 = slicesRef.current) == null ? void 0 : _slicesRef$current2.clientHeight) || 0
    });
  };

  useObserver(runInObserver, slicesRef); // get image width and height

  useEffect(function () {
    var myImage = new Image();

    myImage.onload = function () {
      setImageDims(getRatioImageSize(containerDims, {
        height: myImage.height,
        width: myImage.width
      }));
    };

    myImage.src = image;
  }, [image, containerDims]); // trigger glitching with random intervals

  useEffect(function () {
    var lowRandom = getRandomNumberBetween(100, 600);
    var highRandom = getRandomNumberBetween(1000, 3000);
    var timer = isGlitching ? lowRandom : highRandom;
    var interval = setInterval(function () {
      setIsGlitching(function (prevGlitching) {
        return !prevGlitching;
      });
    }, timer);
    return function () {
      return clearInterval(interval);
    };
  }, [isGlitching]); // create heightOffsets array with container height

  useEffect(function () {
    setHeightOffsets(createSlices(containerDims.height));
  }, [containerDims.height, containerDims.width]);
  return React.createElement("div", {
    style: {
      height: '100%',
      width: '100%'
    },
    ref: slicesRef
  }, heightOffsets.map(function (heightOffset, i) {
    return React.createElement("div", {
      key: i,
      style: {
        position: 'relative',
        height: heightOffset.height,
        overflow: 'hidden'
      }
    }, React.createElement(Slice, {
      isGlitching: isGlitching,
      top: heightOffset.offset,
      imageHeight: imageDims.height,
      image: image
    }));
  }));
};

export { GlitchedImage };
//# sourceMappingURL=react-image-glitch.esm.js.map
